{"title":"Manacher算法及应用","date":"2022-01-04T22:13:25.000Z","date_formatted":{"ll":"2022年1月4日","L":"2022/01/04","MM-DD":"01-04"},"thumbnail":"https://ichrisj.gitee.io/reslib/images/thumbnails/snow%20trees%20on%20trail.jpg","link":"2022/01/04/manacher-algo","comments":true,"tags":["LeetCode"],"categories":["Algorithms"],"updated":"2022-09-15T04:52:56.374Z","content":"<p>回文串(palindrome string)是算法题中比较常见的类型。根据回文的定义我们知道它是轴对称的，所以判断一个字符串是不是回文很容易，我们只需要从字符串的两头向中间遍历，只有两侧一直相等才是回文，哪怕一次两侧不相等都不是回文。</p>\n<h3 id=\"中心扩展\">中心扩展<a title=\"#中心扩展\" href=\"#中心扩展\"></a></h3>\n<p>那怎么在一个字符串中找出其中的回文子串呢？貌似也不是很难，我们只需要在每个字符上向两侧扩展，直到两侧不相等就停下来，这样就得到了一个回文子串了。这个方式没错，但是会有遗漏。因为回文串的中轴可能是某个字符，也可能在两个字符中间。例如：“aba&quot;就是以’b’位中轴的回文串；而&quot;abba&quot;却是以&quot;bb&quot;中间为轴的回文，这样的中轴是虚轴。<br>\n这样虚中轴的回文子串应该怎么找呢？其实根上面原理一样，只是需要把中轴由虚变实。我们把所有字符中间插入一个同样的占位符(包括左右两侧)，比如用’#'，则&quot;abba&quot;就变了成”#a#b#b#a#&quot;，那么以最中间的’#'为中轴，就可以找出它是一个回文串。</p>\n<blockquote>\n<p>此时你会发现&quot;abba&quot;的长度是4，而&quot;#a#b#b#a#“的长度是9，那么我只需统计”#a#b#b#a#&quot;半径，就可以s算出&quot;abba&quot;真实的长度。例如以中间’#'向左右两边的距离都是5，那么再减一就是真实长度4。</p>\n<p>同样对于&quot;aba&quot;, 加入占位符后为&quot;#a#b#a#&quot;，中间’b’到左右两边的距离都是4，再减一就是真实长度3。</p>\n</blockquote>\n<h3 id=\"manacher算法\">Manacher算法<a title=\"#manacher算法\" href=\"#manacher算法\"></a></h3>\n<p>好了，现在我们知道如何找出一个字符串中的回文子串，但是之前的方式好像还是不够好？我们需要在字符串的每个位置停下来，然后向两边扩展，找出以此字符为中轴的回文子串，那么最坏的情况是以字符串的中间字符为中轴一直扩展到两边，扩展就要花费O(n)的时间，加上遍历字符串的时间，那么这个方式的时间复杂度就是O(n²)。<br>\n如何才能降低其时间复杂度呢？我们来看看这种情况：<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher1.jpg\" alt=\"\" loading=\"lazy\"><br>\n假设在某个时刻遍历到<code>i</code>的位置，<code>c</code>是<code>i</code>之前的某个位置，在<code>c</code>位置发现的回文串的右边界最远，假设为<code>R</code>，对称的左边界是<code>L</code>。假设<code>i'</code>是<code>i</code>以<code>c</code>为中心的对称位置。因为已经遍历到<code>i</code>位置了，所以我们肯定直到<code>i'</code>和<code>c</code>位置回文子串的情况。<code>i'</code>的回文子串长度为<code>Di'</code>，<code>i</code>的回文子串的长度是<code>Di</code>。</p>\n<ol>\n<li>\n<p>如果<code>i'</code>的回文子串在<code>[L...R]</code>内，那么<code>Di</code>和<code>Di'</code>会是什么关系呢？<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher2.jpg\" alt=\"\" loading=\"lazy\"><br>\n<code>Di</code>和<code>Di'</code>肯定是相等的，并且<code>i</code> 和<code>i'</code>的回文子串肯定也是以<code>c</code>为中心轴对称的。因为<code>[L...R]</code>内的字符都是以<code>c</code>为中心的轴对称，<code>i</code> 和<code>i'</code>是以<code>c</code>为中心的对称，那么它俩各自的回文子串也不例外。例如:<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher21.jpg\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>如果<code>i'</code>的回文子串左侧一部分在<code>[L...R]</code>外呢？<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher3.jpg\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>根据上面的分析，因为轴对称，首先我们可以确认<code>[L ... i' + i' - L]</code>与<code>[i - (R - i) ... R]</code>部分应该是轴对称，所以相等的。那么有没有可能<code>R + 1</code>与<code>L - 1</code>位置的字符相等呢？<br>\n答案是没有可能。因为<code>R + 1</code>与<code>L - 1</code>位置是以<code>c</code>为中心堆成，如果<code>R + 1</code>与<code>L - 1</code>位置字符相同，那么以<code>c</code>为中心的回文串应该是<code>[L-1 ... R + 1]</code>。</li>\n<li>那么有没有可能<code>[i - (R - i) ... R]</code> 左右外侧（即<code>i - (R - i) -1</code>与<code>R + 1</code>）的字符对称相等呢？<br>\n也是不可能。如果相等，因为<code>c</code>为中心对称，那么<code>i - (R - i) -1</code>与<code>i' + i' - L + 1</code>是相等的。又由于<code>i'</code>的回文子串，<code>L - 1</code>与<code>i' + i' - L + 1</code>相等，那么<code>L - 1</code>与<code>i - (R - i) -1</code>相等，那么与<code>R + 1</code>也相等了，那么以<code>c</code>为中心的回文串又是<code>[L-1 ... R + 1]</code>了。</li>\n<li>所以以<code>i</code>为中心的回文子串是<code>[i - (R - i) ... R]</code>。例如：<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher31.jpg\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n</li>\n<li>\n<p>如果<code>i'</code>的回文子串左边界正好在<code>L</code>上呢？<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher4.jpg\" alt=\"\" loading=\"lazy\"><br>\n此时我们可以确认以<code>i'</code> 的回文子串的范围是<code>[L ... i' + i' - L]</code>。与之对应，<code>[i - (R - i) ... R]</code>部分满足以<code>i</code>为中心的回文子串。那此处的回文字符串会不会更宽呢？<br>\n这个是有可能的。因为<code>R + 1</code>与<code>i - (R - i) -1</code>相等，<code>i - (R - i) -1</code>与<code>i' + i' - L + 1</code>相等，那么<code>R + 1</code>与<code>i' + i' - L + 1</code>相等。但是<code>i' + i' - L + 1</code>与<code>L - 1</code>位置字符不相等，所以<code>R + 1</code>与<code>L - 1</code>不相等，不影响之前的假设。所以在此种情况下，需要尝试再向两边扩展。但是<code>[i - (R - i) ... R]</code>不需要在计算的，这部分已经满足要求了。例如：<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/manacher-algo/manacher41.jpg\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>但是没有之前的假设情况怎么办？<code>i</code>在<code>R</code>的右端怎么办呢？回到原来朴素的方式去查找回文子串，然后将此时的<code>i</code>设为<code>c</code>，它的右边界设为<code>R</code>, <code>i</code>跳到下一步，看看是否满足上面的条件，满足则以上面的情况查找，不满足，继续此朴素查找。</p>\n</li>\n</ol>\n<h3 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h3>\n<p>我们将上述两点融合在算法中.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算字符串中最长的回文字串的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MaxLCPSLength</span>(<span class=\"params\"><span class=\"built_in\">string</span> str</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span> || str.Length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">char</span>[] manacherStr = ManacherChars(str);</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] diameters = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[manacherStr.Length]; <span class=\"comment\">// 以每个字符为中心的回文字串的长度</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> center = <span class=\"number\">-1</span>; <span class=\"comment\">// 当前到达最右边界回文子串的中心下标</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> right_border = <span class=\"number\">-1</span>; <span class=\"comment\">// 当前最右回文子串右边界下标</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> maxLen = <span class=\"built_in\">int</span>.MinValue; <span class=\"comment\">// 记录最长回文子串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; manacherStr.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 i 大于等于右边界, 则 i 位置中心子串的默认长度为1. 之后需要两边扩展.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 i 在右边界左侧, 则先算 i&#x27; 位置子串长度:</span></span><br><span class=\"line\">        <span class=\"comment\">// - 如果在[L..R]内, 那么 i&#x27; 位置子串长度肯定小于 right_border - i</span></span><br><span class=\"line\">        <span class=\"comment\">// - 否则, i&#x27; 位置子串长度肯定不小于 right_border - i.</span></span><br><span class=\"line\">        diameters[i] = right_border &gt; i ? Math.Min(right_border - i, diameters[<span class=\"number\">2</span> * center - i]) : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 为了减少代码量, 不管 i 位置子串长度如何, 都尝试去两边扩展. 如果第一次扩展失败, 说明不用扩展了,直接跳出.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果扩展成功,则继续扩展, 直到失败.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i + diameters[i] &lt; manacherStr.Length &amp;&amp; i - diameters[i] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (manacherStr[i + diameters[i]] == manacherStr[i - diameters[i]])</span><br><span class=\"line\">                diameters[i]++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果计算出 i 位置子串右边界已经超过原有的右边界, 则更新最右边界和中心点.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + diameters[i] &gt; right_border)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right_border = i + diameters[i];</span><br><span class=\"line\">            center = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxLen = Math.Max(maxLen, diameters[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxLen - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 经字符串中插入占位符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">char</span>[] <span class=\"title\">ManacherChars</span>(<span class=\"params\"><span class=\"built_in\">string</span> str</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">char</span>[] res = <span class=\"keyword\">new</span> <span class=\"built_in\">char</span>[<span class=\"number\">2</span> * str.Length + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; res.Length; i++)</span><br><span class=\"line\">        res[i] = i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"string\">&#x27;#&#x27;</span> : str[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"算法中的应用\">算法中的应用<a title=\"#算法中的应用\" href=\"#算法中的应用\"></a></h3>\n<p>To be continued…</p>\n","prev":{"title":"Call External APIs within Power Apps Portal","link":"2022/09/15/call-external-apis-within-power-apps-portals"},"next":{"title":"浅谈KMP算法","link":"2021/12/27/kmp-algo"},"plink":"http://b.alphac.cn/2022/01/04/manacher-algo/","toc":[{"id":"中心扩展","title":"中心扩展","index":"1"},{"id":"manacher算法","title":"Manacher算法","index":"2"},{"id":"代码","title":"代码","index":"3"},{"id":"算法中的应用","title":"算法中的应用","index":"4"}],"copyright":{"link":"<a href=\"http://b.alphac.cn/2022/01/04/manacher-algo/\" title=\"Manacher算法及应用\">http://b.alphac.cn/2022/01/04/manacher-algo/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"2022年1月4日"},"reading_time":"1936 字约 16 分钟"}