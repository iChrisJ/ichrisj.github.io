{"title":"数据结构之的位图","date":"2022-12-05T00:00:00.000Z","date_formatted":{"ll":"Dec 5, 2022","L":"12/05/2022","MM-DD":"12-05"},"thumbnail":"https://ichrisj.gitee.io/reslib/images/bitmap/thumbnail.jpg","link":"2022/12/05/bitmap","comments":true,"tags":["Bit Manipulation","BitMap"],"categories":["Algorithms"],"updated":"2022-12-05T14:44:12.250Z","content":"<h1 id=\"为什么用位图\">为什么用位图<a title=\"#为什么用位图\" href=\"#为什么用位图\"></a></h1>\n<p>我们来考虑一个问题：假如这里有堆数字，然后问你某个数字是否在这堆数字中，该怎么办？我们首先想到的办法可能是将这堆数字放到一个 HashSet 中去，然后调用 Contains 方法一查就知道在不在了。这个没有问题，但是否可以有节省空间的方法呢？</p>\n<p>如果这堆数字是在0 ~ 31之间，是否一定要将这些数字放在 HashSet 中才能快速的查出是否在某个数字在不在呢？通常一个 int 类型的数字 num，4个字节32位，通常它只能表示一个数字。如果我们用它的每一位表示0 ~ 31的每个数字。如果一个数在这堆数字中，我们将 num 中32位中对应的位上设置为1。例如，如果这堆数字是5, 17, 26, 30，那么就分别在 num 的第5, 17, 26, 30位上置1。之后如果想知道某个数在不在，只要查询 num 对应位的值是否为1即可。<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/bitmap/1.png\" alt=\"bit\" loading=\"lazy\"></p>\n<p>如此逻辑，一个int的数字可以最多表示32数字，节省了32倍的空间。如果用long类型，最多可以表示64个数字是否存在。</p>\n<h2 id=\"如果数字的范围更大呢？\">如果数字的范围更大呢？<a title=\"#如果数字的范围更大呢？\" href=\"#如果数字的范围更大呢？\"></a></h2>\n<p>前面我们假设了这堆数字在0 ~ 31之间，这太理想了。如果范围更大呢？在0 ~ 1000 之间呢？</p>\n<p>一个 int 有32位可以代表32个数字，俩个 int 就可以代表64个数字。依此类推，32个int就可以代表1024个数字，这就可以覆盖0 ~ 1000的范围了。多了几位没用没关系，但是不可以缺少。</p>\n<p>如果数字的范围有负数呢？例如 -500 ~ 500呢？其实还是可以用32个int去代表的，加上一个500的偏移量就可以了。例如第一个int的第0位原本代表数字0，现在偏移500，代表数字 -500就可以了。</p>\n<h1 id=\"位图的实现样例\">位图的实现样例<a title=\"#位图的实现样例\" href=\"#位图的实现样例\"></a></h1>\n<p>这里我们用long类型来实现代码，可以表示更多的数字</p>\n<h2 id=\"bitmap的构造\">bitmap的构造<a title=\"#bitmap的构造\" href=\"#bitmap的构造\"></a></h2>\n<p>虽然用long类型，最多也就可以代表64个数字。如果表示更大范围的数字，那么我们就需要更多的long类型数字了，那么就需要一个long类型的数组字段了。</p>\n<p>假设数据的范围是<code>0 ~ max</code>，那么数组的长度就是 <code>max / 64 + 1</code>才能确保覆盖到所有的数组。转换成位运算就是 <code>(max &gt;&gt; 6) + 1</code>， 计算机对位运算的速度肯定比加减乘除快很多。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BitMap</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">long</span>[] bits;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitMap</span>(<span class=\"params\"><span class=\"built_in\">int</span> max</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bits = <span class=\"keyword\">new</span> <span class=\"built_in\">long</span>[(max &gt;&gt; <span class=\"number\">6</span>) + <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加数字\">添加数字<a title=\"#添加数字\" href=\"#添加数字\"></a></h2>\n<p>现在要将一个数字 num 放入 BitMap，我们需要知道代表该数字的是 bits 数组中的哪个数字的哪一位。因为一个 long 类型的数字最多只能代表64个数。用 <code>num / 64</code> 就知道是数组中的第几位数字。例如，如果 <code>num == 1000</code>, 那么 <code>1000 / 64 == 15</code>, 那么就是 bit 数组中的 第16个数字中的某一位能覆盖到1000，正好该数字在数组中的下标是15。</p>\n<p>现在如何确定是该数组二进制中的哪一位并且将其修改呢？如果 <code>num == 65</code>，我们知道是<code>bit[1]</code>二进制位的第1位(开始为0)，如果 <code>num == 130</code>，我们知道是<code>bit[2]</code>二进制位的第2位。由此可知二进制位中具体哪一位可以通过<code>num % 64</code>得的余数算出。用位运算代替模运算就是<code>num &amp; 63</code>。</p>\n<p>现在知道了具体位置，要将该位置的值设为1，就可以或上一个数，该数在该位置的值是1，其他位置为0，可以通过<code>1L &lt;&lt; (num % 64)</code>获取。那么经过或运算，其他位置的值是不会变的，该位置的值如果原来不是1就会被设置成1了。添加的动作就完成了</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bits[num &gt;&gt; <span class=\"number\">6</span>] |= (<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除数字\">删除数字<a title=\"#删除数字\" href=\"#删除数字\"></a></h2>\n<p>删除的操作其实和添加的操作一样，只是在找到正确位置后需要将该位置的值设置为0，其他位置的值保持不变。</p>\n<p>添加操作我们可以通过<code>1L &lt;&lt; (num &amp; 63)</code>可以获得一个在对应位置上值为1，其他位置为0的数，此时取反，就得到一个对应位置的值为0，其他位置为1的数。那么在做个与操作，就可以确保其他位置值不变，对应位置的值被设置成1了。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Delete</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bits[num &gt;&gt; <span class=\"number\">6</span>] &amp;= ~(<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"包含数字\">包含数字<a title=\"#包含数字\" href=\"#包含数字\"></a></h2>\n<p>前面的分析我们知道<code>bits[num &gt;&gt; 6]</code>可以得到 bits 数组上表示 num 的数，<code>1L &lt;&lt; (num &amp; 63)</code>可以获得一个在对应位置上值为1，其他位置为0的数。如果<code>bits[num &gt;&gt; 6]</code>二进制位中代表 num 的位的值是 0，那么和<code>1L &lt;&lt; (num &amp; 63)</code>进行与运算，结果是是0，那么就是不包含。如果<code>bits[num &gt;&gt; 6]</code>二进制位中代表 num 的位的值是 1, 进行与运算后的结果肯定是大于0的，就是包含。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Contains</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (bits[num &gt;&gt; <span class=\"number\">6</span>] &amp; (<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>))) != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>完整代码</strong>:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BitMap</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">long</span>[] bits;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitMap</span>(<span class=\"params\"><span class=\"built_in\">int</span> max</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bits = <span class=\"keyword\">new</span> <span class=\"built_in\">long</span>[(max &gt;&gt; <span class=\"number\">6</span>) + <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bits[num &gt;&gt; <span class=\"number\">6</span>] |= (<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Delete</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bits[num &gt;&gt; <span class=\"number\">6</span>] &amp;= ~(<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Contains</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (bits[num &gt;&gt; <span class=\"number\">6</span>] &amp; (<span class=\"number\">1L</span> &lt;&lt; (num &amp; <span class=\"number\">63</span>))) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"Dynamics Marketing: Call a Plugin When a Trigger is Fired","link":"2022/12/16/call-plugins-when-a-trigger-is-fired"},"next":{"title":"等概率随机函数问题","link":"2022/11/23/equal-probability"},"plink":"https://blog.citysouth.cc/2022/12/05/bitmap/","toc":[{"id":"为什么用位图","title":"为什么用位图","index":"1","children":[{"id":"如果数字的范围更大呢？","title":"如果数字的范围更大呢？","index":"1.1"}]},{"id":"位图的实现样例","title":"位图的实现样例","index":"2","children":[{"id":"bitmap的构造","title":"bitmap的构造","index":"2.1"},{"id":"添加数字","title":"添加数字","index":"2.2"},{"id":"删除数字","title":"删除数字","index":"2.3"},{"id":"包含数字","title":"包含数字","index":"2.4"}]}],"copyright":{"license":"自由转载-非商用-禁止演绎-保持署名 Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"December 5, 2022"},"reading_time":"1447 words in 12 min"}