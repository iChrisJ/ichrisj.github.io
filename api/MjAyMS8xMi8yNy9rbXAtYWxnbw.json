{"title":"浅谈KMP算法","date":"2021-12-27T16:35:13.000Z","date_formatted":{"ll":"Dec 27, 2021","L":"12/27/2021","MM-DD":"12-27"},"thumbnail":"/images/thumbnails/photo-1436699005328-ac3965e80aa7.jpg","link":"2021/12/27/kmp-algo","comments":true,"categories":["Algorithms"],"updated":"2024-11-02T17:04:02.960Z","content":"<p>字符串匹配是计算机中比较基本的操作。暴力的做法就是将两个字符串str和pattern从<code>0</code>位置开始匹配，如果中间有字符不匹配，则str跳回开始位置的下一位，即<code>1</code>位置，pattern跳回0位置，两者再继续匹配。依此类推，如果pattern上所有字符在str的某个位置开始后都能匹配上，那么则找到了一个匹配的位置；如果str到达结束的位置都没有找到找个位置，那么str上就没有匹配pattern的位置。</p>\n<p>这个方法的算法复杂度是<code>O(n*m)</code>(str和pattern长度分别是n,m，其中n&gt;=m), 是效率比较低的。那么更高效的方法是什么呢？其中之一是KMP算法(Knuth–Morris–Pratt algorithm)，它可以把时间复杂度降到O(n+m)，即O(n)。</p>\n<h3 id=\"kmp算法逻辑\">KMP算法逻辑<a title=\"#kmp算法逻辑\" href=\"#kmp算法逻辑\"></a></h3>\n<p>很多效率高的算法都是用空间换时间，KMP算法也是。它会对pattern字符串生成一个next数组。next数组存储了pattern中前缀等于后缀的最大的长度。</p>\n<p>当str和pattern在匹配过程中的某个时刻<code>str[i]</code>和<code>pattern[j]</code>不相等，pattern不一定要跳回到<code>0</code>位置，而是在next数组中查出跳回到哪个位置后，继续与<code>str[i]</code>匹配。</p>\n<h3 id=\"next数组的计算\">next数组的计算<a title=\"#next数组的计算\" href=\"#next数组的计算\"></a></h3>\n<p>next数组是针对pattern字符串的, 其中<code>next[i]</code>是指<code>pattern[0...i-1]</code>之间前缀等于后缀的最大长度，但是不可以是<code>i</code>。例如，pattern中前<code>i</code>个字符是&quot;abbacabba&quot;, 那我们看看它的前缀和后缀：</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">长度</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">前缀</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">ab</td>\n<td style=\"text-align:center\">abb</td>\n<td style=\"text-align:center\">abba</td>\n<td style=\"text-align:center\">abbac</td>\n<td style=\"text-align:center\">abbaca</td>\n<td style=\"text-align:center\">abbacab</td>\n<td style=\"text-align:center\">abbacabb</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">后缀</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">ba</td>\n<td style=\"text-align:center\">bba</td>\n<td style=\"text-align:center\">abba</td>\n<td style=\"text-align:center\">cabba</td>\n<td style=\"text-align:center\">acabba</td>\n<td style=\"text-align:center\">bacabba</td>\n<td style=\"text-align:center\">bbacabba</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相等?</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n</tbody>\n</table></div></div><p>所以这里<code>next[i] = 4</code>。⚠️注意：不可以计算这个&quot;abbacabba&quot;，因为其长度是<code>i</code>。如果计算了那么前缀和后缀永远是一样的。</p>\n<p>那么生成next数组的代码如何表达呢？</p>\n<ul>\n<li>对于pattern字符串的<code>0</code>位置，它前面没有任何字符，这里人为设<code>next[0] = -1</code>。</li>\n<li>对于<code>1</code>位置，它前面就一个字符，没法算前缀和后缀，这里也人为设<code>next[1] = 0</code>.</li>\n<li>对<code>i</code>位置，我们先假设<code>cn = next[i-1]</code>，根据next数组的定义可以知道<code>pattern[0...i-2]</code>中前缀和后缀相等的最大长度是cn，即<code>pattern[0...cn-1] == pattern[i-cn-1...i-2]</code>。此时，如果:\n<ul>\n<li><code>pattern[cn] == pattern[i-1]</code>, 那么<code>next[i] = cn + 1</code>， <code>i</code>和<code>cn</code>都可以右移继续比较去计算<code>next[i+1]</code>了。</li>\n<li><code>pattern[cn] != pattern[i-1]</code>, 那么获取<code>cn</code>位置的<code>next[cn]</code>的值，假设是<code>cn'</code>。那么就有<code>pattern[0...cn'-1] == pattern[cn-cn'...cn-1]</code>；因为之前说去<code>pattern[0...cn-1] == pattern[i-cn-1...i-2]</code>，那么<code>pattern[i-cn-1...i-2]</code>肯定也存在一个<code>cn'</code>长度使得<code>pattern[i-cn-1...i-cn-1+(cn'-1)] == pattern[i-2-(cn'-1)...i-2]</code>,那么也就有<code>pattern[0...cn'-1] == pattern[i-2-(cn'-1)...i-2]</code>。此时回到第一步的逻辑，如果<code>pattern[cn'] == pattern[i-1]</code>, 则<code>next[i] = cn' + 1</code>，<code>i</code>和<code>cn'</code>右移；如果<code>pattern[cn'] ！= pattern[i-1]</code>，继续第二步的逻辑，获取<code>cn'</code>位置的<code>next[cn']</code>的值，一直向前找满足要求的<code>cn</code>。</li>\n<li>但是，如果<code>cn</code>已经跳到<code>0</code>位置了，退无可退了，那么<code>next[i] == 0</code>，即<code>i</code>位置没有满足要求的前缀和后缀。</li>\n</ul>\n</li>\n</ul>\n<p>例如pattern = “abcabdabcabf” (这里就每一步都分析了):</p>\n<ul>\n<li>next数组的<code>0</code> <code>1</code>位置的值是固定的。</li>\n<li>对于index = 6，因为它的前一位<code>next[5] == 2</code>，即<code>pattern[0..1] == pattern[3..4]</code>, 但<code>pattern[2] != pattern[5]</code>, 那么查找<code>next[2] == 0</code>，但<code>pattern[0] != pattern[5]</code>。那么继续找<code>next[0]</code>,此时已经是<code>0</code>位置了，那么<code>next[6] = 0</code>；</li>\n<li>当index = 11时，它的前一位<code>next[10] == 4</code>, 即<code>pattern[0..3] == pattern[6..9]</code>, 此时<code>pattern[4] != pattern[10]</code>，那么<code>next[11] = 5</code>;</li>\n</ul>\n<p><img src=\"/images/kmp-algo/next.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] <span class=\"title\">NextArray</span>(<span class=\"params\"><span class=\"built_in\">string</span> pattern</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pattern.Length == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[] &#123; <span class=\"number\">-1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[pattern.Length];</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> cn = <span class=\"number\">0</span>; <span class=\"comment\">//当前与i-1位置字符比较的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; next.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pattern[i - <span class=\"number\">1</span>] == pattern[cn])</span><br><span class=\"line\">            next[i++] = ++cn;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cn &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            cn = next[cn];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            next[i++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"kmp匹配过程\">KMP匹配过程<a title=\"#kmp匹配过程\" href=\"#kmp匹配过程\"></a></h3>\n<p>现在next数组已经生成好了，那么如果用匹配字符串呢？</p>\n<ul>\n<li>首先str和pattern字符串都是从<code>0</code>位置出发进行一一匹配。</li>\n<li>假设str和pattern分别在<code>i</code>, <code>j</code>位置时不相等，去next数组查找<code>next[j]</code>的值，假设是<code>j'</code>。此时让<code>str[i]</code>与<code>next[j']</code>比较：\n<ul>\n<li>如果相等，str和pattern的<code>i</code>, <code>j'</code>各自右移，继续下一步的比较；</li>\n<li>如果不等，next数组中查找<code>next[j']</code>，继续与<code>str[i]</code>比较，如此反复；</li>\n<li>如果此时<code>next[j'] == -1</code>，即查找到达<code>pattern[0]</code>了还是没找到, 那么就str就从<code>i+1</code>位置开始重新与pattern匹配</li>\n</ul>\n</li>\n<li>如果<code>j</code>到达了pattern右端，说明完全匹配成功了，str上的位置就是<code>i-j</code>。如果<code>i</code>先到达str的右端，就是没有匹配成功。</li>\n</ul>\n<p>例如对于str = “<strong>abcabdabcab</strong>ef”, pattern = “<strong>abcabdabcab</strong>f”。由上我们可以计算出next数组是<code>[-1, 0, 0, 0, 1, 2, 0, 1, 2, 3, 4, 5]</code>。那么当str和pattern匹配到index=11是<code>str[11] = 'e'</code>, <code>pattern[11] = 'f'</code>，那么在next数组中查得<code>next[11] == 5</code>, 我们发现<code>pattern[0...4]</code>(长度是5)和<code>str[11]</code>之前的5个字符完全相等。那么我只需要比较<code>str[11]</code>与<code>pattern[5]</code>是否相等，如果相等，继续向右匹配，不用跳回到起点再匹配了。</p>\n<p>这里<code>str[11] != pattern[5]</code>，再从next数组查得<code>next[5] == 2</code>。同样，<code>pattern[0...1]</code>与<code>str[11]</code>之前的2个字符完全相等，那么比较<code>str[11]</code>与<code>pattern[2]</code>是否相等, 以此类推, 直到<code>next[0] == -1</code>，说明pattern中没有字符能满足匹配条件与str[11]匹配上，那么只能从str[11]的下一位重新开始匹配。</p>\n<p><img src=\"/images/kmp-algo/kmp.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">KMPMatch</span>(<span class=\"params\"><span class=\"built_in\">string</span> str, <span class=\"built_in\">string</span> pattern</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span> || str.Length == <span class=\"number\">0</span> || pattern == <span class=\"literal\">null</span> || pattern.Length == <span class=\"number\">0</span> || str.Length &lt; pattern.Length)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] next = NextArray(pattern); <span class=\"comment\">// O(M) m &lt;= n;</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; str.Length &amp;&amp; j &lt; pattern.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str[i] == pattern[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (next[j] == <span class=\"number\">-1</span>) <span class=\"comment\">// j == 0</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == pattern.Length ? i - j : <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"Manacher算法及应用","link":"2022/01/04/manacher-algo"},"next":{"title":"配置多个Git账号","link":"2021/12/25/configure-multiple-git-accounts"},"plink":"https://blog.citysouth.cc/2021/12/27/kmp-algo/","toc":[{"id":"kmp算法逻辑","title":"KMP算法逻辑","index":"1"},{"id":"next数组的计算","title":"next数组的计算","index":"2"},{"id":"kmp匹配过程","title":"KMP匹配过程","index":"3"}],"copyright":{"license":"自由转载-非商用-禁止演绎-保持署名 Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"December 27, 2021"},"reading_time":"1606 words in 13 min"}