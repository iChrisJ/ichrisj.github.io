{"title":"算法题中归并的应用","date":"2022-09-15T12:52:56.374Z","date_formatted":{"ll":"Sep 15, 2022","L":"09/15/2022","MM-DD":"09-15"},"thumbnail":"https://ichrisj.gitee.io/reslib/images/thumbnails/mohammad-alizade-CDu0x1Aiils-unsplash.jpg","link":"2022/09/15/merge-in-algorithm-problems","comments":true,"tags":["LeetCode"],"categories":["Algorithms"],"updated":"2022-09-15T04:52:56.374Z","content":"<p>归并排序相信大家都很熟悉, 是比较常见的排序算法，其时间复杂度在O(nlogn)。那么我们在LeetCode刷题过程中，它会有哪些应用呢？</p>\n<h3 id=\"归并排序\">归并排序<a title=\"#归并排序\" href=\"#归并排序\"></a></h3>\n<p>首先，我们来回顾一下归并排序。其实归并排序主要就两个部分: 对数组的左右部分递归调用自己，然后对左右俩部分进行归并。熟悉二叉树遍历的同学肯定会发现，这就是二叉树的后续遍历。</p>\n<p>其实，归并的作用是使左右俩部分有序的数组变成一个完整的有序数组。也就是说，归并操作的前提条件是左右俩部分必须有序。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">MergeSort</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] arr, <span class=\"built_in\">int</span> left, <span class=\"built_in\">int</span> right</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> mid = left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    MergeSort(arr, left, mid);</span><br><span class=\"line\">    MergeSort(arr, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\"></span><br><span class=\"line\">    Merge(arr, left, mid, right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"算法题应用\">算法题应用<a title=\"#算法题应用\" href=\"#算法题应用\"></a></h3>\n<p>那么，如果一些算法题中，如果数组的左右两部分已经有序了，是否这些题会更容易找到解法呢？</p>\n<h4 id=\"数组中的逆序对📎\">数组中的逆序对<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/\">📎</a><a title=\"#数组中的逆序对📎\" href=\"#数组中的逆序对📎\"></a></h4>\n<blockquote>\n<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n<blockquote>\n<p>示例 1:<br>\n输入: [7,5,6,4]<br>\n输出: 5</p>\n</blockquote>\n<blockquote>\n<p>限制：<br>\n0 &lt;= 数组长度 &lt;= 50000</p>\n</blockquote>\n</blockquote>\n<p>我们先来两个数(小于两个数,就可以直接返回0了), 例如[7, 5]。其实，一看就知道这是一组逆序对，但让我们用归并排序的思想就分析一下。<br>\n<img src=\"https://ichrisj.gitee.io/reslib/images/merge-in-algorithm-problems/reverse-pairs.jpg\" alt=\"reverse-pairs\" loading=\"lazy\"></p>\n<p>首先数组的左右俩部分都是有序的，因为各自就一个数。对于右边<strong>5</strong>来说，在左边从<strong>7</strong>到中间位置都比<strong>5</strong>大。那么从<strong>7</strong>到中间的位置，总共有1个数，则有一组逆序对。之后将[7, 5]排序。</p>\n<p>同理，对于[6, 4], 分析它们也是一组逆序对。然后排序。</p>\n<p>排完序后，数组变成[5, 7, 4, 6]。从右边部分开始看，对于<strong>4</strong>，在左边部分，因为<strong>5</strong>比<strong>4</strong>大，那么从<strong>5</strong>到中间的位置，都可以与<strong>4</strong>组成逆序对，那么有 mid + 1 - index 组逆序对，即 1 + 1 - 0 = 2 (这里左边部分不用从<strong>5</strong>开始向右一一遍历与<strong>4</strong>比较，因为这部分是有序的，肯定都不会小于<strong>5</strong>)；之后看<strong>6</strong>，因为左边的<strong>5</strong>小，则左边边向右移动到<strong>7</strong>，其比<strong>6</strong>大，则对于<strong>6</strong>来说，右边有 1 + 1 - 1 = 1个数可以它组成逆序对。右边部分遍历结束，归并排序将数组变有序。</p>\n<p>最后，我们就统计出总共有5组逆序对。</p>\n<blockquote>\n<p>注意：在merge排序到达过程中，如果某个位置左右两边的值相等，应先将左边的值先放入辅助数组中。如果先将右边的数放入辅助数组中，可能会造成结果变小。例如，左右两个分别是a, b(a == b)。如果此时a的下一位是c(c &gt; a)。如果先把a放入辅助数组，c还可以与b组成逆序对。但是如果b先放入辅助数组，那么c就不能与b组成逆序对，导致结果变小。</p>\n</blockquote>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">ReversePairs</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums == <span class=\"literal\">null</span> || nums.Length &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ReversePairs(nums, <span class=\"number\">0</span>, nums.Length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"title\">ReversePairs</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> le, <span class=\"built_in\">int</span> ri</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(le == ri)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> mid = le + ((ri - le) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ReversePairs(nums, le, mid) </span><br><span class=\"line\">        + ReversePairs(nums, mid + <span class=\"number\">1</span>, ri) </span><br><span class=\"line\">        + Merge(nums, le, mid, ri);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"title\">Merge</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> le, <span class=\"built_in\">int</span> mid, <span class=\"built_in\">int</span> ri</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] aux = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[ri - le + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 辅助数组中当前位置</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> l = le, r = mid + <span class=\"number\">1</span>; <span class=\"comment\">//nums数组中左右位置</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt;= mid &amp;&amp; r &lt;= ri) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果左边l的值比右边r的值大，那么[l..mid]之间所有的数都比r位置的数大</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么左边就有mid - l + 1个数可以与r组成逆序对</span></span><br><span class=\"line\">        res += nums[l] &gt; nums[r] ? (mid - l + <span class=\"number\">1</span>) : <span class=\"number\">0</span>; </span><br><span class=\"line\">        aux[i++] = nums[l] &lt;= nums[r] ? nums[l++] : nums[r++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt;= mid)</span><br><span class=\"line\">        aux[i++] = nums[l++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r &lt;= ri)</span><br><span class=\"line\">        aux[i++] = nums[r++];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; aux.Length; i++)</span><br><span class=\"line\">        nums[le + i] = aux[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"计算右侧小于当前元素的个数📎\">计算右侧小于当前元素的个数<a href=\"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\">📎</a><a title=\"#计算右侧小于当前元素的个数📎\" href=\"#计算右侧小于当前元素的个数📎\"></a></h4>\n<blockquote>\n<p>给你一个整数数组nums，按要求返回一个新数组counts。数组counts有该性质：counts[i]的值是nums[i]右侧小于nums[i]的元素的数量。</p>\n<p>示例 1：</p>\n<blockquote>\n<p>输入：nums = [5, 2, 6, 1]<br>\n输出：[2, 1, 1, 0]<br>\n解释：<br>\n5 的右侧有 2 个更小的元素 (2 和 1)<br>\n2 的右侧仅有 1 个更小的元素 (1)<br>\n6 的右侧有 1 个更小的元素 (1)<br>\n1 的右侧有 0 个更小的元素</p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://ichrisj.gitee.io/reslib/images/merge-in-algorithm-problems/count-smaller.jpg\" alt=\"count smaller\" loading=\"lazy\"><br>\n我们还是从小范围看起，先看[5, 2]。首先左右俩边都是有序的，因为各自就一个数。对于左边的<strong>5</strong>，右边的<strong>2</strong>比其小。所以目前<strong>5</strong>右侧比其小的数量是1。<strong>2</strong>右边目前没数，所以答案是0。得到目前答案后，排序。</p>\n<p>同理，对于数组[6, 1], <strong>6</strong>右边的<strong>1</strong>比其小，目前答案是1。<strong>1</strong>右边没数，答案是0。得到目前答案，排序。</p>\n<p>上面左右部分排完序之后数组是[2, 5, 1, 6]。此时设置两个指针<em>l</em>, <em>r</em>分别指向左边的<strong>5</strong>和右边的<strong>6</strong>。此时<strong>5</strong>&lt;<strong>6</strong>, <em>r</em>向左移动到<strong>1</strong>，此时 <strong>5</strong>&gt;<strong>1</strong>, 那么此时[mid + 1, r]之间的所有数都是小于<strong>5</strong>，满足要求的，即总共有 r - mid (2 - 1 = 1)个，加上之前的1个，<strong>5</strong>右边满足要求的数量是2个。之后，l向左移动到<strong>2</strong>，此时 <strong>2</strong>&gt;<strong>1</strong>, 满足要求，那么<strong>2</strong>右边有1个数满足要求。<em>l</em>继续左移，超出数组边界结束。</p>\n<p>至此，我们便得到数组[5, 2, 6, 1]的答案[2, 1, 1, 0]。</p>\n<p>但是，如何把答案填入返回数组对应位置上呢？因为数组nums是被排序的，每个值都可能会被移动的。其实，我们可以在用一个新的数组，这个数组的每个元素不但有原数组的元素的值，还携带元素的下标，这样在排序过程中，我们始终可以获取元素的原来下标，并将答案更新到返回数组中。(这里我懒得使用数组或创建一个对象去包含元素的值和下标，直接使用的C#中的元组了)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] smaller;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IList&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">CountSmaller</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"literal\">null</span> || nums.Length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        smaller = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[nums.Length];</span><br><span class=\"line\">        (<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>)[] keyNums = <span class=\"keyword\">new</span> (<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>)[nums.Length]; <span class=\"comment\">//元组数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.Length; i++)</span><br><span class=\"line\">            keyNums[i] = (nums[i], i); <span class=\"comment\">// 初始化元组，第一个是元素的值，第二个是下标</span></span><br><span class=\"line\">        CountSmaller(keyNums, <span class=\"number\">0</span>, nums.Length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;(smaller);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">CountSmaller</span>(<span class=\"params\">(<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span></span>)[] keyNums, <span class=\"built_in\">int</span> le, <span class=\"built_in\">int</span> ri)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(le == ri)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">int</span> mid = le + ((ri - le) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        CountSmaller(keyNums, le, mid);</span><br><span class=\"line\">        CountSmaller(keyNums, mid + <span class=\"number\">1</span>, ri);</span><br><span class=\"line\">        Merge(keyNums, le, mid, ri);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Merge</span>(<span class=\"params\">(<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span></span>)[] keyNums, <span class=\"built_in\">int</span> le, <span class=\"built_in\">int</span> mid, <span class=\"built_in\">int</span> ri)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> l = mid, r = ri;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &gt;= le &amp;&amp; r &gt; mid)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果nums[l] &lt;= nums[r]，不满足条件，r向左移动</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(keyNums[l].Item1 &lt;= keyNums[r].Item1)</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则，[mid + 1， r]之间的数都满足要求，更新结果。l向左移。</span></span><br><span class=\"line\">                smaller[keyNums[l].Item2] += r - mid;</span><br><span class=\"line\">                l--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        (<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>)[] aux = <span class=\"keyword\">new</span> (<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>)[ri - le + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        l = le;</span><br><span class=\"line\">        r = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= mid &amp;&amp; r &lt;= ri)</span><br><span class=\"line\">            aux[i++] = keyNums[l].Item1 &lt;= keyNums[r].Item1 ? keyNums[l++] : keyNums[r++];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= mid)</span><br><span class=\"line\">            aux[i++] = keyNums[l++];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &lt;= ri)</span><br><span class=\"line\">            aux[i++] = keyNums[r++];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; aux.Length; i++)</span><br><span class=\"line\">            keyNums[i + le] = aux[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面两题的分析逻辑基本上差不多，大家可以自己解答一下<br>\n翻转对<a href=\"https://leetcode-cn.com/problems/reverse-pairs/\" target=\"_blank\">📎</a><br>\n区间和的个数<a href=\"https://leetcode-cn.com/problems/count-of-range-sum/\" target=\"_blank\">📎</a></p>\n","prev":{"title":"Seamless sign in Portal with ADFS","link":"2022/09/15/seamless-sign-in-portal-with-adfs"},"next":{"title":"Hello World","link":"2022/09/15/hello-world"},"plink":"https://blog.citysouth.cc/2022/09/15/merge-in-algorithm-problems/","toc":[{"id":"归并排序","title":"归并排序","index":"1"},{"id":"算法题应用","title":"算法题应用","index":"2","children":[{"id":"数组中的逆序对📎","title":"数组中的逆序对📎","index":"2.1"},{"id":"计算右侧小于当前元素的个数📎","title":"计算右侧小于当前元素的个数📎","index":"2.2"}]}],"copyright":{"link":"<a href=\"https://blog.citysouth.cc/2022/09/15/merge-in-algorithm-problems/\" title=\"算法题中归并的应用\">https://blog.citysouth.cc/2022/09/15/merge-in-algorithm-problems/</a>","license":"自由转载-非商用-禁止演绎-保持署名 Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"September 15, 2022"},"reading_time":"2041 words in 17 min"}